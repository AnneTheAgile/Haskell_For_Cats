Haskell_For_Cats:

'Cause if cats can do this so can you!
=============
The plan is to do thirteen weeks of Haskell 
	from the beginning . . .  
		using Graham Hutton's Book Programming Haskell  
		and Erik Meijer's Video series Functional Programming in Haskell 
			which mirrors the above mentioned book.
 
	This will be for those that have never programmed before 
	but also for those who have programmed in other languages and paradigms
		(namely O.O.P. and pocedural and/or iterative)  
		but are new to the functional approach.

---------------------------------------------	

	Why Haskell? 

	Because it's fast: (out of the box), 
		as fast as Java and a whole lot sweeter.
			and (with tweaking) 
			it can be as fast as C++, 
			with a lower error rate.
	
	Because Haskell will scale, presently to 40+ cores on one machine. 
			Most other languages will choke on a faction of that load.  
	
	Because it is terse and concise: 
		The stats are: 1.4 bugs per 100 lines of code, 
		requardless of the language.
		Less lines of code = less bugs.
		
	Because it is strongly typed:
		Strong typing reduces mismatch errors. 
		'cause if some idiot can, some idiot will; 
		and late at night after the nth beer 
			that idiot might just be you.
	
	Because Haskell is self documenting
		wanna know what a function does just ask it.
		It will tell you what it takes in 
		and what it gives back, always!
	
   Because Haskell weeds out sloppy programming habits. 
      If it is sloppily done it wont compile. 

	Because Haskell is faster to working code. 
		'cause once Haskell has compiled you are more than half done.

	Because there is less to test. 
		Pure functions, reduce your testing surface. 
		Same imputs yeild same results regardless of context. 
		Immutability, means less shared memory. 
		Haskell is NOT fragile!  

	Haskell has a direct connection to Lambda Calculus; it strives for mathmatical purity. 
		In Haskell: mathmatics and computer science converge rather than lock horns.

---------------------------
		
	Where would you use it?
	
	Anywhere you need: 
		many-core concurrency 
      big sort
		big compute, 
		fast matching,
      quick transforms
		and better security (for free)
		
		
	
	And you can use it in addition to other languages; 
	it is strength where and win you need it, 
	and it's pretty too. 

	 

