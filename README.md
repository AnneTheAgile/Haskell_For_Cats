Haskell_For_Cats:

'Cause if cats can do this so can you!
=============
<<<<<<< HEAD

http://www.meetup.com/Haskell_For_Cats/

The plan is to do thirteen chapters of Haskell using Graham Hutton's Book "Programming Haskell" plus 
	Erik Meijer's Video series "Functional Programming Fundamentals," 
	in Haskell, which mirrors the above mentioned book. 
	
 	
 	We will meet every two weeks and bang through two chapters and two vids at a time. 
=======
The plan is to do thirteen weeks of Haskell 
	from the beginning . . .  
		using Graham Hutton's Book "Programming Haskell"  
		and Erik Meijer's Video series Functional Programming in Haskell
 
			which mirrors the above mentioned book.
>>>>>>> primes gets odds
 
	This will be for those that have never programmed 
		but are open to learning.  
	
	Also welcome are those who have programmed in other languages and paradigms
		(namely O.O.P. and pocedural and/or iterative)  
		but are new to the functional approach. 
video
https://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1
	you can watch on line or download. The links to the next 12 videos are there as well. 

---------------------------------------------	

	Why Haskell? 
<<<<<<< HEAD
=======

	Because it's fast: (out of the box), 
		as fast as Java and a whole lot sweeter.
			and (with tweaking) 
			it can be as fast as C++, 
			with a lower error rate.
>>>>>>> primes gets odds
	
	Because memory is NOW cheap enough and so are CPUs and GPUs.
	
	Because Haskell is fast: (out of the box), 
		as fast as Java and way more terse.
		and (with tweaking) 
		Haskell can be as fast as C++, 
		with less errors.
	
<<<<<<< HEAD
	Because Haskell will scale: 
		presently to 40+ cores* and 
		reach 20+ million new requests per second 
		on a single machine.
		Most other languages will choke on a faction of that load.  
	
	Because Haskell is terse and concise: 
		The stats are: 1.4 bugs per 100 lines of code, 
		requardless of the language.
		Less lines of code = less bugs.
		
	Because Haskell favors lazy evaluation:
		It can work with infinite values, and not blow the stack, 
		Haskell just calls only what it needs only when it needs it.
=======
	Because it is terse and concise: 
		The stats are: 1.4 bugs per 100 lines of code, 
		requardless of the language.
		Less lines of code = less bugs.
>>>>>>> primes gets odds
		
	Because it is strongly typed:
		Strong typing reduces mismatch errors. 
		'cause if some idiot can, some idiot will; 
		and late at night after the nth beer 
			that idiot might just be you.
	
	Because Haskell is self documenting
		wanna know what a function does just ask it.
		It will tell you what it takes in 
<<<<<<< HEAD
		and what it gives back, 
		always!
=======
		and what it gives back, always!
	
   Because Haskell weeds out sloppy programming habits. 
      If it is sloppily done it wont compile. 

	Because Haskell is faster to working code. 
		'cause once Haskell has compiled you are more than half done.

	Because there is less to test. 
		Pure functions, reduce your testing surface. 
		Same imputs yeild same results regardless of context. 
		Immutability, means less shared memory. 
		Haskell is NOT fragile!  
>>>>>>> primes gets odds

	Because Haskell is faster to WORKING code. 
		Once Haskell has compiled you are half done.
		
	Because Haskell is almost entirely stateless, there is much less to test.
		Pure functions, are immutable, and unchanging.  
		The same inputs will always yeild the same results, always. 
		 
	Haskell has a direct connection to Lambda Calculus; it strives for mathmatical purity. 
		In Haskell: mathmatics and computer science converge rather than lock horns.
<<<<<<< HEAD
		You don't have to think math + computor, you can think just the math instead. 
=======
>>>>>>> primes gets odds

---------------------------
		
	Where would you use it?
	
	Anywhere you need: 
		many-core concurrency 
<<<<<<< HEAD
      		big sort
		big compute, 
		fast matching,
      		quick transformations
		and better security.
	
	And you can use it in addition to other languages; 
	it is strength where and 
	win you need it, 
	and it's pretty to. =) 
	 
-----------------------------
FootNotes: * the 40 cores ref: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf

Additonal resources. . . .

Brian Beckman explained the monand so well even my cat gets it. 
http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads

Brian Beckman interviews Rich Hickey: two of the greatest explicators in a single video.
http://channel9.msdn.com/Shows/Going+Deep/Expert-to-Expert-Rich-Hickey-and-Brian-Beckman-Inside-Clojure
=======
      big sort
		big compute, 
		fast matching,
      quick transformations
		and better security.
	
	And you can use it in addition to other languages; 
	it is strength where and win you need it, 
	and it's pretty too. 
	 
>>>>>>> primes gets odds
